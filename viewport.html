<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Added shrink-to-fit=no to stop Safari auto‑zoom when width overflows in standalone landscape mode -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover" />
  <title>Viewport Metrics</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    h1 { font-size: 1.5rem; margin-bottom: 1rem; }
    dl { display: grid; grid-template-columns: max-content 1fr; row-gap: 0.5rem; column-gap: 1rem; }
    dt { font-weight: 600; }
    dd { margin: 0; }
    h2 { margin-top: 2rem; font-size: 1.25rem; }
    #log { list-style: none; padding-left: 0; max-height: 280px; overflow-y: auto; border: 1px solid #ccc; border-radius: 0.5rem; padding: 0.5rem; }
    #log li { font-family: monospace; font-size: 0.85rem; margin: 0.25rem 0; }
  </style>
</head>
<body>
  <h1>Viewport Metrics (auto‑updates)</h1>
  <dl>
    <dt>visualViewport.width:</dt><dd id="vvp-w">–</dd>
    <dt>visualViewport.height:</dt><dd id="vvp-h">–</dd>
    <dt>visualViewport.scale:</dt><dd id="vvp-scale">–</dd>
    <dt>window.innerWidth:</dt><dd id="win-w">–</dd>
    <dt>window.innerHeight:</dt><dd id="win-h">–</dd>
    <dt>screen.orientation.type:</dt><dd id="screen-o">–</dd>
    <dt>100dvw:</dt><dd id="dvw">–</dd>
    <dt>100dvh:</dt><dd id="dvh">–</dd>
    <dt>100vw:</dt><dd id="vw">–</dd>
    <dt>100vh:</dt><dd id="vh">–</dd>
  </dl>

  <h2>Event log</h2>
  <ul id="log"></ul>

  <!-- Elements used solely for measurement -->
  <div id="measure-d" style="position:absolute;width:100dvw;height:100dvh;pointer-events:none;visibility:hidden;"></div>
  <div id="measure"   style="position:absolute;width:100vw;height:100vh;pointer-events:none;visibility:hidden;"></div>

  <script>
    (function () {
      const els = {
        vvpW:   document.getElementById('vvp-w'),
        vvpH:   document.getElementById('vvp-h'),
        vvpS:   document.getElementById('vvp-scale'),
        winW:   document.getElementById('win-w'),
        winH:   document.getElementById('win-h'),
        scrO:   document.getElementById('screen-o'),
        dvw:    document.getElementById('dvw'),
        dvh:    document.getElementById('dvh'),
        vw:     document.getElementById('vw'),
        vh:     document.getElementById('vh'),
      };
      const measureD = document.getElementById('measure-d');
      const measure  = document.getElementById('measure');
      const logEl = document.getElementById('log');

      function log(msg) {
        const li = document.createElement('li');
        li.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
        logEl.prepend(li);
        if (logEl.children.length > 200) logEl.removeChild(logEl.lastChild);
      }

      function orientationLabel() {
        return screen.orientation ? screen.orientation.type : (window.orientation === 90 || window.orientation === -90 ? 'landscape' : 'portrait');
      }

      function update(label) {
        const vvp = window.visualViewport;
        els.vvpW.textContent = vvp.width.toFixed(2)  + ' px';
        els.vvpH.textContent = vvp.height.toFixed(2) + ' px';
        els.vvpS.textContent = vvp.scale.toFixed(3);

        els.winW.textContent = window.innerWidth + ' px';
        els.winH.textContent = window.innerHeight + ' px';

        els.scrO.textContent = orientationLabel();

        els.dvw.textContent  = measureD.offsetWidth  + ' px';
        els.dvh.textContent  = measureD.offsetHeight + ' px';
        els.vw.textContent   = measure.offsetWidth   + ' px';
        els.vh.textContent   = measure.offsetHeight  + ' px';
        if (label) log(label);
      }

      function bind(target, type, label) {
        target.addEventListener(type, () => update(label), { passive: true });
      }

      // Initial paint
      update('initial update');

      // Event listeners
      bind(window, 'resize', 'window resize');
      bind(window, 'orientationchange', 'orientationchange');
      if (screen.orientation) bind(screen.orientation, 'change', 'screen.orientation change');
      bind(window.visualViewport, 'resize', 'visualViewport resize');
      bind(window.visualViewport, 'scroll', 'visualViewport scroll');
      // Throttle‑style polling every 750 ms to capture potential oscillation frames.
      //setInterval(() => update('interval refresh'), 750);
    })();
  </script>
</body>
</html>
