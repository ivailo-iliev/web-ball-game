<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="/favicon.png" sizes="any" type="image/png">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <title>WebGPU video</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font: 14px system-ui, sans-serif;
    }

    /* Canvas: preserve aspect ratio automatically */
    #gfx {
      position: fixed;
      /* ignore the page flow */
      top: 50%;
      left: 50%;

      /* make a viewport-sized box so the bitmap can scale inside it */
      width: 100dvw;
      height: 100dvh;

      /* keep the canvas bitmapâ€™s intrinsic aspect ratio */
      object-fit: contain;
      transform-origin: center;

      /* center the elementâ€™s box, then we can add rotation in portrait */
      transform: translate(-50%, -50%);

      image-rendering: pixelated;
      background: #000;
    }

    /* PORTRAIT: rotate and instead fill height, cap by width â€” preserves ratio */
    @media (orientation: portrait) {
      #gfx {
        transform: translate(-50%, -50%) rotate(90deg);
        width: 100dvh;
        /* ðŸ‘ˆ swap */
        height: 100dvw;
        /* ðŸ‘ˆ swap */
      }
    }

    #config {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: auto;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      width: 100%;
    }

    fieldset { border: 0; padding: 0; }
    fieldset pre { display: inline; }

    input {
      width: 6ch;
    }
  </style>
</head>

<body>
  <canvas id="gfx"></canvas>
  <div id="config">
    <fieldset>
      <pre id="state">Connecting...</pre>
      <button id="b0" disabled>Send 0</button>
    </fieldset>
    <fieldset>
      <button id="start">Start</button>
      <input id="videoWidth" type="number" placeholder="width" />
      <input id="videoHeight" type="number" placeholder="height" />
    </fieldset>
    <fieldset>
      <select id="teamA">
      <option value="0">ðŸ”´</option>
      <option value="1">ðŸŸ¢</option>
      <option value="2">ðŸ”µ</option>
      <option value="3">ðŸŸ¡</option>
    </select>
      <input id="domA" type="number" placeholder="domA" step="0.01" />
      <input id="yMinA" type="number" placeholder="yMinA" step="0.01" />
    </fieldset>
    <fieldset>
      <select id="teamB">
      <option value="0">ðŸ”´</option>
      <option value="1">ðŸŸ¢</option>
      <option value="2">ðŸ”µ</option>
      <option value="3">ðŸŸ¡</option>
    </select>
      <input id="domB" type="number" placeholder="domB" step="0.01" />
      <input id="yMinB" type="number" placeholder="yMinB" step="0.01" />
    </fieldset>
    <fieldset>
      <input id="radiusPx" type="number" placeholder="radius" />
      <input id="minArea" type="number" placeholder="min area" />
    </fieldset>
    <span id="info"></span>
  </div>

  <script src="utils.js"></script>
  <script src="webrtc.js"></script>
  <script src="config.js"></script>
  <script src="detect.js"></script>
  <script>
    (function () {
      'use strict';
      const { createConfig } = window;
    const state = $('#state');
    const b0 = $('#b0');

    function handleOpen() {
      state.textContent = 'Connected';
      b0.disabled = false;
      b0.onclick = () => sendBit('0');
    }

    let dc;

    function handleDcOpen() {
      state.textContent = 'dc: open';
      dc.send('hello from A');
      handleOpen();
    }

    function handleStartCtrl(ctrl) {
      dc = ctrl.channel;
      if (!dc) { state.textContent = 'No data channel'; return; }
      dc.onopen = handleDcOpen;
      dc.onmessage = e => console.log('msg:', e.data);
    }

    StartA().then(handleStartCtrl).catch(err => {
      state.textContent = 'ERR: ' + (err && (err.stack || err));
    });

    function sendBit(bit) {
      if (dc && dc.readyState === 'open') {
        dc.send(bit);
        console.log(`[${new Date().toISOString()}] sent hit ${bit}`);
      }
    }
    window.sendBit = sendBit;

    const info = $('#info');
      let infoBase = '';
      let lastFrameTS;
    const start = $('#start');
    const canvas = $('#gfx');
    const widthInput = $('#videoWidth');
    const heightInput = $('#videoHeight');
    const minAreaInput = $('#minArea');
    const radiusInput = $('#radiusPx');
    const domAInput = $('#domA');
    const domBInput = $('#domB');
    const yMinAInput = $('#yMinA');
    const yMinBInput = $('#yMinB');
    const selA = $('#teamA');
    const selB = $('#teamB');

    const DOM_THR_DEFAULT = 0.20; // try 0.15..0.25
    const YMIN_DEFAULT    = 0.20; // try 0.18..0.25
    const RADIUS_DEFAULT  = 60;

    const DEFAULTS = {
      topResW: 1280,
      topResH: 720,
      topMinArea: 600,
      teamA: 1,
      teamB: 2,
      domThr: [DOM_THR_DEFAULT, DOM_THR_DEFAULT, DOM_THR_DEFAULT, DOM_THR_DEFAULT],
      yMin:  [YMIN_DEFAULT,    YMIN_DEFAULT,    YMIN_DEFAULT,    YMIN_DEFAULT],
      topRadiusPx: RADIUS_DEFAULT
    };

    const Config = createConfig(DEFAULTS);
    Config.load();
    const cfg = Config.get();
    cfg.domThr = Float32Array.from(cfg.domThr);
    cfg.yMin = Float32Array.from(cfg.yMin);

    let teamA = cfg.teamA;
    let teamB = cfg.teamB;
    let domThrA = cfg.domThr[teamA];
    let domThrB = cfg.domThr[teamB];
    let yMinA = cfg.yMin[teamA];
    let yMinB = cfg.yMin[teamB];

    widthInput.value = cfg.topResW;
    heightInput.value = cfg.topResH;
    minAreaInput.value = cfg.topMinArea;
    radiusInput.value = cfg.topRadiusPx;
    domAInput.value = domThrA;
    domBInput.value = domThrB;
    yMinAInput.value = yMinA;
    yMinBInput.value = yMinB;

    function onWidthInput(e) {
      cfg.topResW = Math.max(1, +e.target.value);
      Config.save('topResW', cfg.topResW);
    }

    function onHeightInput(e) {
      cfg.topResH = Math.max(1, +e.target.value);
      Config.save('topResH', cfg.topResH);
    }

    function onMinAreaInput(e) {
      cfg.topMinArea = Math.max(0, +e.target.value);
      Config.save('topMinArea', cfg.topMinArea);
    }

    function onRadiusInput(e) {
      cfg.topRadiusPx = Math.max(0, +e.target.value);
      Config.save('topRadiusPx', cfg.topRadiusPx);
    }

    function onDomAInput(e) {
      cfg.domThr[teamA] = domThrA = +e.target.value;
      Config.save('domThr', Array.from(cfg.domThr));
    }

    function onDomBInput(e) {
      cfg.domThr[teamB] = domThrB = +e.target.value;
      Config.save('domThr', Array.from(cfg.domThr));
    }

    function onYMinAInput(e) {
      cfg.yMin[teamA] = yMinA = +e.target.value;
      Config.save('yMin', Array.from(cfg.yMin));
    }

    function onYMinBInput(e) {
      cfg.yMin[teamB] = yMinB = +e.target.value;
      Config.save('yMin', Array.from(cfg.yMin));
    }

    widthInput.addEventListener('input', onWidthInput);
    heightInput.addEventListener('input', onHeightInput);
    minAreaInput.addEventListener('input', onMinAreaInput);
    radiusInput.addEventListener('input', onRadiusInput);
    domAInput.addEventListener('input', onDomAInput);
    domBInput.addEventListener('input', onDomBInput);
    yMinAInput.addEventListener('input', onYMinAInput);
    yMinBInput.addEventListener('input', onYMinBInput);

    selA.value = String(teamA);
    selB.value = String(teamB);

    function onChangeTeamA(e) {
      teamA = cfg.teamA = +e.target.value;
      Config.save('teamA', teamA);
      domThrA = cfg.domThr[teamA];
      yMinA = cfg.yMin[teamA];
      domAInput.value = domThrA;
      yMinAInput.value = yMinA;
    }

    function onChangeTeamB(e) {
      teamB = cfg.teamB = +e.target.value;
      Config.save('teamB', teamB);
      domThrB = cfg.domThr[teamB];
      yMinB = cfg.yMin[teamB];
      domBInput.value = domThrB;
      yMinBInput.value = yMinB;
    }

    selA.addEventListener('change', onChangeTeamA);
    selB.addEventListener('change', onChangeTeamB);

    start.addEventListener('click', onStartClick);


    async function onStartClick() {
      start.disabled = true;
      infoBase = '';
      try {
        // 1) Camera â†’ WebCodecs VideoFrame (no <video> element)
        const videoConstraints = { facingMode: 'user', frameRate: { ideal: 60 } };
        const w = parseInt(widthInput.value, 10);
        if (!isNaN(w)) videoConstraints.width = { ideal: w };
        const h = parseInt(heightInput.value, 10);
        if (!isNaN(h)) videoConstraints.height = { ideal: h };
        const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: false });
        const track = stream.getVideoTracks()[0];

        // 2) detection will internally init WebGPU; just keep a simple busy flag
        let busy = false; // drop frames when main thread is busy
        // 5) Worker: iOS Safari exposes MediaStreamTrackProcessor only in a Dedicated Worker.
        //    We transfer the camera track to the worker; it posts VideoFrames back to main.
        const workerSrc = /* js */`
        self.onmessage = async (e) => {
          const { op } = e.data || {};
          if (op === 'init-track') {
            const { track } = e.data;
            if (!track) return;
            // Create MSTP in worker and stream frames to main
            const processor = new MediaStreamTrackProcessor({ track });
            const reader = processor.readable.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } else if (op === 'init-stream') {
            const { stream } = e.data;
            if (!stream) return;
            const reader = stream.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } // else ignore
        };
      `;
        const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: 'text/javascript' }));
        const videoWorker = new Worker(workerURL);
        URL.revokeObjectURL(workerURL);

        // Try to transfer the MediaStreamTrack to the worker first (iOS-friendly).
        // If this throws (e.g., Chrome Windows), fall back to sending a ReadableStream.
        try {
          videoWorker.postMessage({ op: 'init-track', track }, [track]);
        } catch (e) {
          const processor = new MediaStreamTrackProcessor({ track });
          videoWorker.postMessage({ op: 'init-stream', stream: processor.readable }, [processor.readable]);
        }

        // 6) Main-thread pump: CEITT â†’ compute(main) â†’ render(vs/fs)
        videoWorker.onmessage = onWorkerMessage;

        async function onWorkerMessage(ev) {
          const frame = ev.data; // VideoFrame (transferred)
          if (!frame) return;
          if (busy) { frame.close(); return; }
          const now = performance.now();
          if (lastFrameTS !== undefined) {
            const fps = 1000 / (now - lastFrameTS);
            info.textContent = `${infoBase} ${fps.toFixed(1)} fps`;
          }
          lastFrameTS = now;
          busy = true;
          try {
            const { a, b, w, h, resized } = await GPUShared.detect({
              key: 'demo',
              source: frame,
              colorA: teamA,
              colorB: teamB,
              domThrA,
              domThrB,
              yMinA,
              yMinB,
              rect: { min: new Float32Array([0, 0]), max: new Float32Array([frame.codedWidth, frame.codedHeight]) },
              previewCanvas: canvas,
              preview: true,
              activeA: true, activeB: true,
              flipY: true,
              radiusPx: cfg.topRadiusPx,
            });
            if (resized) {
              canvas.width = frame.displayWidth;
              canvas.height = frame.displayHeight;
              infoBase = `Running ${w}Ã—${h}, shader.wgsl compute+render (VideoFrame).`;
              info.textContent = infoBase;
            }
            const aOn = a[0] > cfg.topMinArea;
            const bOn = b[0] > cfg.topMinArea;
            if (aOn || bOn) {
              let bit;
              if (aOn && bOn) bit = '2';
              else if (aOn) bit = '0';
              else if (bOn) bit = '1';
              if (bit !== undefined && window.sendBit) window.sendBit(bit);
            }
          } finally {
            frame.close(); // always release
            busy = false;
          }
        }

      } catch (err) {
        info.textContent = (err && err.message) ? err.message : String(err);
        start.disabled = false;
        console.error(err);
      }
    }
    })();
  </script>

</body>

</html>
