<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="/favicon.png" sizes="any" type="image/png">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <title>WebGPU video</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font: 14px system-ui, sans-serif;
    }

    /* Canvas: preserve aspect ratio automatically */
    #gfx {
      position: fixed;
      /* ignore the page flow */
      top: 50%;
      left: 50%;

      /* make a viewport-sized box so the bitmap can scale inside it */
      width: 100dvw;
      height: 100dvh;

      /* keep the canvas bitmapâ€™s intrinsic aspect ratio */
      object-fit: contain;
      transform-origin: center;

      /* center the elementâ€™s box, then we can add rotation in portrait */
      transform: translate(-50%, -50%);

      image-rendering: pixelated;
      background: #000;
    }

    /* PORTRAIT: rotate and instead fill height, cap by width â€” preserves ratio */
    @media (orientation: portrait) {
      #gfx {
        transform: translate(-50%, -50%) rotate(90deg);
        width: 100dvh;
        /* ðŸ‘ˆ swap */
        height: 100dvw;
        /* ðŸ‘ˆ swap */
      }
    }

    #config {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: auto;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      width: 100%;
    }

    fieldset { border: 0; padding: 0; }
    fieldset pre { display: inline; }

    input {
      width: 6ch;
    }
  </style>
</head>

<body>
  <canvas id="gfx"></canvas>
  <div id="config">
    <fieldset>
      <pre id="state">Connecting...</pre>
      <button id="b0" disabled>Send 0</button>
    </fieldset>
    <fieldset>
      <button id="start">Start</button>
      <input id="videoWidth" type="number" placeholder="width" />
      <input id="videoHeight" type="number" placeholder="height" />
    </fieldset>
    <fieldset>
      <select id="teamA"></select>
      <select id="teamB"></select>
      <input id="minArea" type="number" placeholder="min area" />
    </fieldset>
    <fieldset id="teamAThresh"></fieldset>
    <span id="info"></span>
  </div>

  <script src="utils.js"></script>
  <script src="webrtc.js"></script>
  <script src="config.js"></script>
  <script src="detect.js"></script>
  <script>
    (function () {
      'use strict';
      const { createConfig } = window;
    const state = $('#state');
    const b0 = $('#b0');

    function handleOpen() {
      state.textContent = 'Connected';
      b0.disabled = false;
      b0.onclick = () => sendBit('0');
    }

    let dc;

    function handleDcOpen() {
      state.textContent = 'dc: open';
      dc.send('hello from A');
      handleOpen();
    }

    function handleStartCtrl(ctrl) {
      dc = ctrl.channel;
      if (!dc) { state.textContent = 'No data channel'; return; }
      dc.onopen = handleDcOpen;
      dc.onmessage = e => console.log('msg:', e.data);
    }

    StartA().then(handleStartCtrl).catch(err => {
      state.textContent = 'ERR: ' + (err && (err.stack || err));
    });

    function sendBit(bit) {
      if (dc && dc.readyState === 'open') {
        dc.send(bit);
        console.log(`[${new Date().toISOString()}] sent hit ${bit}`);
      }
    }
    window.sendBit = sendBit;

    const info = $('#info');
      let infoBase = '';
      let lastFrameTS;
    const start = $('#start');
    const canvas = $('#gfx');
    const widthInput = $('#videoWidth');
    const heightInput = $('#videoHeight');
    const minAreaInput = $('#minArea');
    const selA = $('#teamA');
    const selB = $('#teamB');
    const thCont = $('#teamAThresh');

    const TEAM_INDICES = { red: 0, yellow: 1, blue: 2, green: 3 };
    const COLOR_TABLE = new Float32Array([
  /* ðŸ”´ */ 0.00, 0.6, 0.35, 0.1, 1, 1,
  /* ðŸŸ¡ */ 0.05, 0.7, 0.40, 0.2, 1, 1,
  /* ðŸ”µ */ 0.50, 0.3, 0.20, 0.7, 1, 1,
  /* ðŸŸ¢ */ 0.70, 0.6, 0.25, 0.9, 1, 1
    ]);
    const savedCT = localStorage.getItem('COLOR_TABLE');
    if (savedCT) {
      try {
        const arr = JSON.parse(savedCT);
        if (Array.isArray(arr) && arr.length === COLOR_TABLE.length) {
          COLOR_TABLE.set(arr.map(Number));
        }
      } catch (e) { }
    }
    const COLOR_EMOJI = { red: 'ðŸ”´', yellow: 'ðŸŸ¡', blue: 'ðŸ”µ', green: 'ðŸŸ¢' };
    const hsvRangeF16 = t => GPUShared.hsvRangeF16(TEAM_INDICES, COLOR_TABLE, t);

    const DEFAULTS = {
      topResW: 1280,
      topResH: 720,
      topMinArea: 600,
      teamA: 'green',
      teamB: 'blue'
    };

    const Config = createConfig(DEFAULTS);
    Config.load({ teamIndices: TEAM_INDICES, hsvRangeF16 });
    const cfg = Config.get();

    widthInput.value = cfg.topResW;
    heightInput.value = cfg.topResH;
    minAreaInput.value = cfg.topMinArea;

    function onWidthInput(e) {
      cfg.topResW = Math.max(1, +e.target.value);
      Config.save('topResW', cfg.topResW);
    }

    function onHeightInput(e) {
      cfg.topResH = Math.max(1, +e.target.value);
      Config.save('topResH', cfg.topResH);
    }

    function onMinAreaInput(e) {
      cfg.topMinArea = Math.max(0, +e.target.value);
      Config.save('topMinArea', cfg.topMinArea);
    }

    widthInput.addEventListener('input', onWidthInput);
    heightInput.addEventListener('input', onHeightInput);
    minAreaInput.addEventListener('input', onMinAreaInput);

    populateTeamSelects(selA, selB, COLOR_EMOJI);
    selA.value = cfg.teamA;
    selB.value = cfg.teamB;
    if (selA.selectedIndex === -1) {
      selA.selectedIndex = 0;
      cfg.teamA = selA.value;
      Config.save('teamA', cfg.teamA);
    }
    if (selB.selectedIndex === -1) {
      selB.selectedIndex = 0;
      cfg.teamB = selB.value;
      Config.save('teamB', cfg.teamB);
    }

    function onChangeTeamA(e) {
      cfg.teamA = e.target.value;
      Config.save('teamA', cfg.teamA);
      updateThreshInputs();
    }

    function onChangeTeamB(e) {
      cfg.teamB = e.target.value;
      Config.save('teamB', cfg.teamB);
    }

    selA.addEventListener('change', onChangeTeamA);
    selB.addEventListener('change', onChangeTeamB);

    const thInputs = [];
    const thFrag = document.createDocumentFragment();
    for (let i = 0; i < 6; i++) {
      const inp = Object.assign(document.createElement('input'), {
        type: 'number',
        min: '0',
        max: '1',
        step: '0.05'
      });
      Object.assign(inp.style, { width: '4ch' });
      inp.dataset.idx = i;
      thInputs.push(inp);
      thFrag.appendChild(inp);
      inp.addEventListener('input', onThresholdInput);
    }
    thCont.appendChild(thFrag);

    function onThresholdInput(e) {
      const i = +e.target.dataset.idx;
      const base = TEAM_INDICES[cfg.teamA] * 6 + i;
      COLOR_TABLE[base] = parseFloat(e.target.value);
      localStorage.setItem('COLOR_TABLE',
        JSON.stringify(Array.from(COLOR_TABLE, v => +v.toFixed(2))));
      cfg.f16Ranges[cfg.teamA] = hsvRangeF16(cfg.teamA);
    }

    function updateThreshInputs() {
      const base = TEAM_INDICES[cfg.teamA] * 6;
      for (let i = 0; i < 6; i++) thInputs[i].value = (+COLOR_TABLE[base + i].toFixed(2));
    }
    updateThreshInputs();

    start.addEventListener('click', onStartClick);

    async function onStartClick() {
      start.disabled = true;
      infoBase = '';
      try {
        // 1) Camera â†’ WebCodecs VideoFrame (no <video> element)
        const videoConstraints = { facingMode: 'user', frameRate: { ideal: 60 } };
        const w = parseInt(widthInput.value, 10);
        if (!isNaN(w)) videoConstraints.width = { ideal: w };
        const h = parseInt(heightInput.value, 10);
        if (!isNaN(h)) videoConstraints.height = { ideal: h };
        const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: false });
        const track = stream.getVideoTracks()[0];

        // 2) detection will internally init WebGPU; just keep a simple busy flag
        let busy = false; // drop frames when main thread is busy
        // 5) Worker: iOS Safari exposes MediaStreamTrackProcessor only in a Dedicated Worker.
        //    We transfer the camera track to the worker; it posts VideoFrames back to main.
        const workerSrc = /* js */`
        self.onmessage = async (e) => {
          const { op } = e.data || {};
          if (op === 'init-track') {
            const { track } = e.data;
            if (!track) return;
            // Create MSTP in worker and stream frames to main
            const processor = new MediaStreamTrackProcessor({ track });
            const reader = processor.readable.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } else if (op === 'init-stream') {
            const { stream } = e.data;
            if (!stream) return;
            const reader = stream.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } // else ignore
        };
      `;
        const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: 'text/javascript' }));
        const videoWorker = new Worker(workerURL);
        URL.revokeObjectURL(workerURL);

        // Try to transfer the MediaStreamTrack to the worker first (iOS-friendly).
        // If this throws (e.g., Chrome Windows), fall back to sending a ReadableStream.
        try {
          videoWorker.postMessage({ op: 'init-track', track }, [track]);
        } catch (e) {
          const processor = new MediaStreamTrackProcessor({ track });
          videoWorker.postMessage({ op: 'init-stream', stream: processor.readable }, [processor.readable]);
        }

        // 6) Main-thread pump: CEITT â†’ compute(main) â†’ render(vs/fs)
        videoWorker.onmessage = onWorkerMessage;

        async function onWorkerMessage(ev) {
          const frame = ev.data; // VideoFrame (transferred)
          if (!frame) return;
          if (busy) { frame.close(); return; }
          const now = performance.now();
          if (lastFrameTS !== undefined) {
            const fps = 1000 / (now - lastFrameTS);
            info.textContent = `${infoBase} ${fps.toFixed(1)} fps`;
          }
          lastFrameTS = now;
          busy = true;
          try {
            const { a, b, w, h, resized } = await GPUShared.detect({
              key: 'demo',
              source: frame,
              hsvA6: cfg.f16Ranges[cfg.teamA],
              hsvB6: cfg.f16Ranges[cfg.teamB],
              rect: { min: new Float32Array([0, 0]), max: new Float32Array([frame.codedWidth, frame.codedHeight]) },
              previewCanvas: canvas,
              preview: true,
              activeA: true, activeB: true,
              flipY: true
            });
            if (resized) {
              canvas.width = frame.displayWidth;
              canvas.height = frame.displayHeight;
              infoBase = `Running ${w}Ã—${h}, shader.wgsl compute+render (VideoFrame).`;
              info.textContent = infoBase;
            }
            const aOn = a[0] > cfg.topMinArea;
            const bOn = b[0] > cfg.topMinArea;
            if (aOn || bOn) {
              let bit;
              if (aOn && bOn) bit = '2';
              else if (aOn) bit = '0';
              else if (bOn) bit = '1';
              if (bit !== undefined && window.sendBit) window.sendBit(bit);
            }
          } finally {
            frame.close(); // always release
            busy = false;
          }
        }

      } catch (err) {
        info.textContent = (err && err.message) ? err.message : String(err);
        start.disabled = false;
        console.error(err);
      }
    }
    })();
  </script>

</body>

</html>
