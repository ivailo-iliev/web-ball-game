<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="/favicon.png" sizes="any" type="image/png">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <title>WebGPU video</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font: 14px system-ui, sans-serif;
    }

    /* Canvas: preserve aspect ratio automatically */
    #gfx {
      position: fixed;
      /* ignore the page flow */
      top: 50%;
      left: 50%;

      /* make a viewport-sized box so the bitmap can scale inside it */
      width: 100dvw;
      height: 100dvh;

      /* keep the canvas bitmapâ€™s intrinsic aspect ratio */
      object-fit: contain;
      transform-origin: center;

      /* center the elementâ€™s box, then we can add rotation in portrait */
      transform: translate(-50%, -50%);

      image-rendering: pixelated;
      background: #000;
    }

    /* PORTRAIT: rotate and instead fill height, cap by width â€” preserves ratio */
    @media (orientation: portrait) {
      #gfx {
        transform: translate(-50%, -50%) rotate(90deg);
        width: 100dvh;
        /* ðŸ‘ˆ swap */
        height: 100dvw;
        /* ðŸ‘ˆ swap */
      }
    }

    #config {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: auto;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      width: 100%;
    }

    fieldset { border: 0; padding: 0; }
    fieldset pre { display: inline; }

    input {
      width: 6ch;
    }
  </style>
</head>

<body>
  <canvas id="gfx"></canvas>
  <div id="config">
    <fieldset>
      <pre id="state">Connecting...</pre>
      <button id="b0" disabled>Send 0</button>
    </fieldset>
    <fieldset>
      <button id="start">Start</button>
      <input id="zoom" type="number" placeholder="zoom" step="0.01" />
    </fieldset>
    <fieldset>
      <select id="teamA">
      <option value="0">ðŸ”´</option>
      <option value="1">ðŸŸ¢</option>
      <option value="2">ðŸ”µ</option>
      <option value="3">ðŸŸ¡</option>
    </select>
      <input id="domA" type="number" placeholder="domA" step="0.01" />
      <input id="satMinA" type="number" placeholder="satMinA" step="0.01" />
      <input id="yMinA" type="number" placeholder="yMinA" step="0.01" />
      <input id="yMaxA" type="number" placeholder="yMaxA" step="0.01" />
    </fieldset>
    <fieldset>
      <select id="teamB">
      <option value="0">ðŸ”´</option>
      <option value="1">ðŸŸ¢</option>
      <option value="2">ðŸ”µ</option>
      <option value="3">ðŸŸ¡</option>
    </select>
      <input id="domB" type="number" placeholder="domB" step="0.01" />
      <input id="satMinB" type="number" placeholder="satMinB" step="0.01" />
      <input id="yMinB" type="number" placeholder="yMinB" step="0.01" />
      <input id="yMaxB" type="number" placeholder="yMaxB" step="0.01" />
    </fieldset>
    <fieldset>
      <input id="radiusPx" type="number" placeholder="radius" />
      <input id="minArea" type="number" placeholder="score thr (0..1)" step="0.005" />
    </fieldset>
    <span id="info"></span>
  </div>

  <script src="utils.js"></script>
  <script src="webrtc.js"></script>
  <script src="config.js"></script>
  <script src="detect.js"></script>
  <script>
    (function () {
      'use strict';
      const { createConfig } = window;
    const state = $('#state');
    const b0 = $('#b0');

    function handleOpen() {
      state.textContent = 'Connected';
      b0.disabled = false;
      b0.onclick = () => sendBit('0');
    }

    let dc;

    function handleDcOpen() {
      state.textContent = 'dc: open';
      dc.send('hello from A');
      handleOpen();
    }

    function handleStartCtrl(ctrl) {
      dc = ctrl.channel;
      if (!dc) { state.textContent = 'No data channel'; return; }
      dc.onopen = handleDcOpen;
      dc.onmessage = e => console.log('msg:', e.data);
    }

    StartA().then(handleStartCtrl).catch(err => {
      state.textContent = 'ERR: ' + (err && (err.stack || err));
    });

    function sendBit(bit) {
      if (dc && dc.readyState === 'open') {
        dc.send(bit);
        console.log(`[${new Date().toISOString()}] sent hit ${bit}`);
      }
    }
    window.sendBit = sendBit;

    const info = $('#info');
      let infoBase = '';
      let lastFrameTS;
    const start = $('#start');
    const canvas = $('#gfx');
    const zoomInput = $('#zoom');
    const minAreaInput = $('#minArea');
    const radiusInput = $('#radiusPx');
    const domAInput = $('#domA');
    const domBInput = $('#domB');
    const satMinAInput = $('#satMinA');
    const satMinBInput = $('#satMinB');
    const yMinAInput = $('#yMinA');
    const yMinBInput = $('#yMinB');
    const yMaxAInput = $('#yMaxA');
    const yMaxBInput = $('#yMaxB');
    const selA = $('#teamA');
    const selB = $('#teamB');

    const DOM_THR_DEFAULT = 0.10; // try 0.05..0.15
    const SATMIN_DEFAULT  = 0.12; // try 0.10..0.15
    const YMIN_DEFAULT    = 0.00; // try 0.00..0.05
    const YMAX_DEFAULT    = 0.70; // try 0.65..0.70
    const RADIUS_DEFAULT  = 18;

    // Camera runs at 19.5:9 (1920Ã—886). Crop width is configurable but
    // height always maintains the aspect ratio.
    const CAM_W = 1920;
    const CAM_H = 886;
    const ASPECT = CAM_H / CAM_W; // â‰ˆ0.4615

    const DEFAULT_CROP_W = 1280;
    const DEFAULT_CROP_H = Math.round(DEFAULT_CROP_W * ASPECT);
    const DEFAULT_ZOOM = CAM_W / DEFAULT_CROP_W;

    const DEFAULTS = {
      topZoom: DEFAULT_ZOOM,
      topResW: DEFAULT_CROP_W,
      topResH: DEFAULT_CROP_H,
      topMinArea: 0.025,
      teamA: 1,
      teamB: 2,
      domThr:  [DOM_THR_DEFAULT, DOM_THR_DEFAULT, DOM_THR_DEFAULT, DOM_THR_DEFAULT],
      satMin: [SATMIN_DEFAULT, SATMIN_DEFAULT, SATMIN_DEFAULT, SATMIN_DEFAULT],
      yMin:   [YMIN_DEFAULT,   YMIN_DEFAULT,   YMIN_DEFAULT,   YMIN_DEFAULT],
      yMax:   [YMAX_DEFAULT,   YMAX_DEFAULT,   YMAX_DEFAULT,   YMAX_DEFAULT],
      topRadiusPx: RADIUS_DEFAULT
    };

    const Config = createConfig(DEFAULTS);
    Config.load();
    const cfg = Config.get();
    cfg.domThr = Float32Array.from(cfg.domThr);
    cfg.satMin = Float32Array.from(cfg.satMin);
    cfg.yMin = Float32Array.from(cfg.yMin);
    cfg.yMax = Float32Array.from(cfg.yMax);

    let teamA = cfg.teamA;
    let teamB = cfg.teamB;
    let domThrA = cfg.domThr[teamA];
    let domThrB = cfg.domThr[teamB];
    let satMinA = cfg.satMin[teamA];
    let satMinB = cfg.satMin[teamB];
    let yMinA = cfg.yMin[teamA];
    let yMinB = cfg.yMin[teamB];
    let yMaxA = cfg.yMax[teamA];
    let yMaxB = cfg.yMax[teamB];

    cfg.topResW = Math.round(CAM_W / cfg.topZoom);
    cfg.topResH = Math.round(cfg.topResW * ASPECT);
    zoomInput.value = cfg.topZoom;
    minAreaInput.value = cfg.topMinArea;
    radiusInput.value = cfg.topRadiusPx;
    domAInput.value = domThrA;
    domBInput.value = domThrB;
    satMinAInput.value = satMinA;
    satMinBInput.value = satMinB;
    yMinAInput.value = yMinA;
    yMinBInput.value = yMinB;
    yMaxAInput.value = yMaxA;
    yMaxBInput.value = yMaxB;

    function onZoomInput(e) {
      cfg.topZoom = Math.max(1, +e.target.value);
      cfg.topResW = Math.round(CAM_W / cfg.topZoom);
      cfg.topResH = Math.round(cfg.topResW * ASPECT);
      Config.save('topZoom', cfg.topZoom);
      Config.save('topResW', cfg.topResW);
      Config.save('topResH', cfg.topResH);
    }

    function onMinAreaInput(e) {
      cfg.topMinArea = Math.max(0, Math.min(1, +e.target.value));
      Config.save('topMinArea', cfg.topMinArea);
    }

    function onRadiusInput(e) {
      cfg.topRadiusPx = Math.max(0, +e.target.value);
      Config.save('topRadiusPx', cfg.topRadiusPx);
    }

    function onDomAInput(e) {
      cfg.domThr[teamA] = domThrA = +e.target.value;
      Config.save('domThr', Array.from(cfg.domThr));
    }

    function onDomBInput(e) {
      cfg.domThr[teamB] = domThrB = +e.target.value;
      Config.save('domThr', Array.from(cfg.domThr));
    }

    function onSatMinAInput(e) {
      cfg.satMin[teamA] = satMinA = +e.target.value;
      Config.save('satMin', Array.from(cfg.satMin));
    }

    function onSatMinBInput(e) {
      cfg.satMin[teamB] = satMinB = +e.target.value;
      Config.save('satMin', Array.from(cfg.satMin));
    }

    function onYMinAInput(e) {
      cfg.yMin[teamA] = yMinA = +e.target.value;
      Config.save('yMin', Array.from(cfg.yMin));
    }

    function onYMinBInput(e) {
      cfg.yMin[teamB] = yMinB = +e.target.value;
      Config.save('yMin', Array.from(cfg.yMin));
    }

    function onYMaxAInput(e) {
      cfg.yMax[teamA] = yMaxA = +e.target.value;
      Config.save('yMax', Array.from(cfg.yMax));
    }

    function onYMaxBInput(e) {
      cfg.yMax[teamB] = yMaxB = +e.target.value;
      Config.save('yMax', Array.from(cfg.yMax));
    }

    zoomInput.addEventListener('input', onZoomInput);
    minAreaInput.addEventListener('input', onMinAreaInput);
    radiusInput.addEventListener('input', onRadiusInput);
    domAInput.addEventListener('input', onDomAInput);
    domBInput.addEventListener('input', onDomBInput);
    satMinAInput.addEventListener('input', onSatMinAInput);
    satMinBInput.addEventListener('input', onSatMinBInput);
    yMinAInput.addEventListener('input', onYMinAInput);
    yMinBInput.addEventListener('input', onYMinBInput);
    yMaxAInput.addEventListener('input', onYMaxAInput);
    yMaxBInput.addEventListener('input', onYMaxBInput);

    selA.value = String(teamA);
    selB.value = String(teamB);

    function onChangeTeamA(e) {
      teamA = cfg.teamA = +e.target.value;
      Config.save('teamA', teamA);
      domThrA = cfg.domThr[teamA];
      satMinA = cfg.satMin[teamA];
      yMinA = cfg.yMin[teamA];
      yMaxA = cfg.yMax[teamA];
      domAInput.value = domThrA;
      satMinAInput.value = satMinA;
      yMinAInput.value = yMinA;
      yMaxAInput.value = yMaxA;
    }

    function onChangeTeamB(e) {
      teamB = cfg.teamB = +e.target.value;
      Config.save('teamB', teamB);
      domThrB = cfg.domThr[teamB];
      satMinB = cfg.satMin[teamB];
      yMinB = cfg.yMin[teamB];
      yMaxB = cfg.yMax[teamB];
      domBInput.value = domThrB;
      satMinBInput.value = satMinB;
      yMinBInput.value = yMinB;
      yMaxBInput.value = yMaxB;
    }

    selA.addEventListener('change', onChangeTeamA);
    selB.addEventListener('change', onChangeTeamB);

    start.addEventListener('click', onStartClick);


    async function onStartClick() {
      start.disabled = true;
      infoBase = '';
      try {
        // 1) Camera â†’ WebCodecs VideoFrame (no <video> element)
        const videoConstraints = {
          facingMode: 'environment',
          frameRate: { ideal: 60 },
          width: { ideal: CAM_W },
          height: { ideal: CAM_H }
        };
        const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: false });
        const track = stream.getVideoTracks()[0];

        // 2) detection will internally init WebGPU; just keep a simple busy flag
        let busy = false; // drop frames when main thread is busy
        // 5) Worker: iOS Safari exposes MediaStreamTrackProcessor only in a Dedicated Worker.
        //    We transfer the camera track to the worker; it posts VideoFrames back to main.
        const workerSrc = /* js */`
        self.onmessage = async (e) => {
          const { op } = e.data || {};
          if (op === 'init-track') {
            const { track } = e.data;
            if (!track) return;
            // Create MSTP in worker and stream frames to main
            const processor = new MediaStreamTrackProcessor({ track });
            const reader = processor.readable.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } else if (op === 'init-stream') {
            const { stream } = e.data;
            if (!stream) return;
            const reader = stream.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } // else ignore
        };
      `;
        const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: 'text/javascript' }));
        const videoWorker = new Worker(workerURL);
        URL.revokeObjectURL(workerURL);

        // Try to transfer the MediaStreamTrack to the worker first (iOS-friendly).
        // If this throws (e.g., Chrome Windows), fall back to sending a ReadableStream.
        try {
          videoWorker.postMessage({ op: 'init-track', track }, [track]);
        } catch (e) {
          const processor = new MediaStreamTrackProcessor({ track });
          videoWorker.postMessage({ op: 'init-stream', stream: processor.readable }, [processor.readable]);
        }

        // 6) Main-thread pump: CEITT â†’ compute(main) â†’ render(vs/fs)
        videoWorker.onmessage = onWorkerMessage;

        async function onWorkerMessage(ev) {
          const frame = ev.data; // VideoFrame (transferred)
          if (!frame) return;
          if (busy) { frame.close(); return; }
          const now = performance.now();
          if (lastFrameTS !== undefined) {
            const fps = 1000 / (now - lastFrameTS);
            info.textContent = `${infoBase} ${fps.toFixed(1)} fps`;
          }
          lastFrameTS = now;
          busy = true;
          // Center crop using zero-copy VideoFrame API for maximum performance
          let cropW = cfg.topResW;
          let cropH = cfg.topResH;
          const frameW = frame.codedWidth;
          const frameH = frame.codedHeight;
          if (cropW > frameW) {
            cropW = frameW;
            cropH = Math.round(cropW * ASPECT);
          }
          if (cropH > frameH) {
            cropH = frameH;
            cropW = Math.round(cropH / ASPECT);
          }
          const ox = Math.max(0, (frameW - cropW) >> 1);
          const oy = Math.max(0, (frameH - cropH) >> 1);
          let cropped;
          try {
            cropped = new VideoFrame(frame, { visibleRect: { x: ox, y: oy, width: cropW, height: cropH } });
            const { a, b, w, h, resized } = await GPUShared.detect({
              key: 'demo',
              source: cropped,
              colorA: teamA,
              colorB: teamB,
              domThrA,
              satMinA,
              yMinA,
              yMaxA,
              domThrB,
              satMinB,
              yMinB,
              yMaxB,
              rect: { min: new Float32Array([0, 0]), max: new Float32Array([cropW, cropH]) },
              previewCanvas: canvas,
              preview: true,
              activeA: true, activeB: true,
              flipY: true,
              radiusPx: cfg.topRadiusPx,
            });
            if (resized) {
              canvas.width = cropped.displayWidth;
              canvas.height = cropped.displayHeight;
              infoBase = `Running ${w}Ã—${h}, shader.wgsl compute+render (VideoFrame).`;
              info.textContent = infoBase;
            }
            const scoreA = (a[0] >>> 16) / 65535;
            const scoreB = (b[0] >>> 16) / 65535;
            const aOn = scoreA >= cfg.topMinArea;
            const bOn = scoreB >= cfg.topMinArea;
            if (aOn || bOn) {
              let bit;
              if (aOn && bOn) bit = '2';
              else if (aOn) bit = '0';
              else if (bOn) bit = '1';
              if (bit !== undefined && window.sendBit) window.sendBit(bit);
            }
          } finally {
            if (cropped) cropped.close();
            frame.close();
            busy = false;
          }
        }

      } catch (err) {
        info.textContent = (err && err.message) ? err.message : String(err);
        start.disabled = false;
        console.error(err);
      }
    }
    })();
  </script>

</body>

</html>
