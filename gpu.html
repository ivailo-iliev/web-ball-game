<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU video â†’ compute(f16) â†’ display (mobile-optimized)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; color:#fff; font:14px system-ui, sans-serif; }
    #wrap { display:grid; place-items:center; gap:12px; height:100%; }
    #gfx { width: min(100vw, 100vh * 9/16); height: auto; image-rendering: pixelated; background:#000; }
    button { padding:10px 16px; font-weight:600; }
    .row { display:flex; gap:12px; align-items:center; }
    @media (orientation: portrait) {
  #gfx { transform: rotate(90deg) translateZ(0); }
}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="gfx"></canvas>
    <div class="row">
      <button id="start">Start</button>
      <input id="videoWidth" type="number" placeholder="width" value="1280" />
      <input id="videoHeight" type="number" placeholder="height" value="720" />
      <span id="info"></span>
    </div>
    <div class="row">
      <label>Min area <input id="topMinInp" type="number" style="width:6ch" /></label>
      <label>Team A
        <select id="teamA">
          <option value="red">ðŸ”´ red</option>
          <option value="yellow">ðŸŸ¡ yellow</option>
          <option value="green">ðŸŸ¢ green</option>
          <option value="blue">ðŸ”µ blue</option>
        </select>
      </label>
      <label>Team B
        <select id="teamB">
          <option value="red">ðŸ”´ red</option>
          <option value="yellow">ðŸŸ¡ yellow</option>
          <option value="green">ðŸŸ¢ green</option>
          <option value="blue">ðŸ”µ blue</option>
        </select>
      </label>
    </div>
    <div class="row" id="teamAThresh"></div>
  </div>

<script type="module">
  const $ = s => document.querySelector(s);
  const info = $('#info');
  const start = $('#start');
  const canvas = $('#gfx');
  const widthInput = $('#videoWidth');
  const heightInput = $('#videoHeight');
  const topMinInp = $('#topMinInp');
  const selA = $('#teamA');
  const selB = $('#teamB');
  const thCont = $('#teamAThresh');

  const TEAM_INDICES = { red: 0, yellow: 1, blue: 2, green: 3 };
  const COLOR_TABLE = new Float32Array([
    /* red    */ 0.00, 0.5, 0.7, 0.10, 1.00, 1.00,
    /* yellow */ 0.10, 0.5, 0.5, 0.20, 1.00, 1.00,
    /* blue   */ 0.50, 0.4, 0.4, 0.70, 1.00, 1.00,
    /* green  */ 0.70, 0.2, 0.2, 0.90, 1.00, 1.00
  ]);
  const savedCT = localStorage.getItem('TOP_COLOR_TABLE');
  if (savedCT) {
    try {
      const arr = JSON.parse(savedCT);
      if (Array.isArray(arr) && arr.length === COLOR_TABLE.length) {
        COLOR_TABLE.set(arr.map(Number));
      }
    } catch(e){}
  }
  const COLOR_EMOJI = { red: 'ðŸ”´', yellow: 'ðŸŸ¡', green: 'ðŸŸ¢', blue: 'ðŸ”µ' };
  function hsvRange(team){
    const i = TEAM_INDICES[team] * 6;
    return COLOR_TABLE.subarray(i, i+6);
  }
  function float32ToFloat16(val){
    const f32 = new Float32Array([val]);
    const u32 = new Uint32Array(f32.buffer)[0];
    const sign = (u32 >> 16) & 0x8000;
    let exp = ((u32 >> 23) & 0xFF) - 127 + 15;
    let mant = u32 & 0x7FFFFF;
    if (exp <= 0) return sign;
    if (exp >= 0x1F) return sign | 0x7C00;
    return sign | (exp << 10) | (mant >> 13);
  }
  function hsvRangeF16(team){
    const src = hsvRange(team);
    const dst = new Uint16Array(6);
    for (let i=0;i<6;i++) dst[i] = float32ToFloat16(src[i]);
    return dst;
  }

  const Config = (() => {
    const DEFAULTS = {
      topMinArea: 600,
      teamA: 'green',
      teamB: 'blue'
    };
    const PERSIST = {
      topMinArea: 'topCamMinArea',
      teamA: 'topTeamA',
      teamB: 'topTeamB'
    };
    let cfg;
    function load(){
      cfg = {};
      for (const [name, def] of Object.entries(DEFAULTS)) {
        const raw = localStorage.getItem(PERSIST[name]);
        cfg[name] = raw !== null ? JSON.parse(raw) : def;
      }
      cfg.f16Ranges = {};
      for (const t of Object.keys(TEAM_INDICES)) {
        cfg.f16Ranges[t] = hsvRangeF16(t);
      }
      return cfg;
    }
    function save(name,val){
      if (PERSIST[name]) localStorage.setItem(PERSIST[name], JSON.stringify(val));
      if (cfg) cfg[name] = val;
    }
    function get(){ return cfg; }
    return { load, save, get };
  })();
  Config.load();
  const cfg = Config.get();

  topMinInp.value = cfg.topMinArea;
  selA.value = cfg.teamA;
  selB.value = cfg.teamB;
  if (selA.selectedIndex === -1) {
    selA.selectedIndex = 0;
    cfg.teamA = selA.value;
    Config.save('teamA', cfg.teamA);
  }
  if (selB.selectedIndex === -1) {
    selB.selectedIndex = 0;
    cfg.teamB = selB.value;
    Config.save('teamB', cfg.teamB);
  }
  topMinInp.addEventListener('input', e => {
    cfg.topMinArea = Math.max(0, +e.target.value);
    Config.save('topMinArea', cfg.topMinArea);
  });
  selA.addEventListener('change', e => {
    cfg.teamA = e.target.value;
    Config.save('teamA', cfg.teamA);
    updateThreshInputs();
  });
  selB.addEventListener('change', e => {
    cfg.teamB = e.target.value;
    Config.save('teamB', cfg.teamB);
  });

  const thInputs = [];
  for (let i = 0; i < 6; i++) {
    const inp = document.createElement('input');
    inp.type = 'number';
    inp.min = '0';
    inp.max = '1';
    inp.step = '0.05';
    inp.style.width = '4ch';
    thCont.appendChild(inp);
    thInputs.push(inp);
    inp.addEventListener('input', e => {
      const base = TEAM_INDICES[cfg.teamA] * 6 + i;
      COLOR_TABLE[base] = parseFloat(e.target.value);
      localStorage.setItem('TOP_COLOR_TABLE',
        JSON.stringify(Array.from(COLOR_TABLE, v => +v.toFixed(2))));
      cfg.f16Ranges[cfg.teamA] = hsvRangeF16(cfg.teamA);
    });
  }
  function updateThreshInputs(){
    const base = TEAM_INDICES[cfg.teamA] * 6;
    for (let i = 0; i < 6; i++) thInputs[i].value = (+COLOR_TABLE[base + i].toFixed(2));
  }
  updateThreshInputs();

  start.addEventListener('click', async () => {
    start.disabled = true;
    try {
      // 1) Camera â†’ WebCodecs VideoFrame (no <video> element)
      const videoConstraints = { facingMode: 'user', frameRate: { ideal: 60 } };
      const w = parseInt(widthInput.value, 10);
      if (!isNaN(w)) videoConstraints.width = { ideal: w };
      const h = parseInt(heightInput.value, 10);
      if (!isNaN(h)) videoConstraints.height = { ideal: h };
      const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: false });
      const track = stream.getVideoTracks()[0];

      // 2) WebGPU (require f16; no fallbacks)
      if (!('gpu' in navigator)) throw new Error('WebGPU not available');
      const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
      if (!adapter) throw new Error('No GPU adapter');
      const device = await adapter.requestDevice({ requiredFeatures: ['shader-f16'] });

      const ctx = canvas.getContext('webgpu');
      const format = navigator.gpu.getPreferredCanvasFormat();
      ctx.configure({ device, format, alphaMode: 'opaque' });

      const blitSampler = device.createSampler({ magFilter: 'nearest', minFilter: 'nearest' });
      let busy = false; // drop frames when main thread is busy

      // 3) GPU resources (textures are created lazily from first VideoFrame)
      let frameTex1, maskTex1;
      let width = 0, height = 0;
      let xGroups = 0, yGroups = 0;
      let bgTop, bgR;
      const WG_X = 8, WG_Y = 32;

      // Uniform & stats buffers (match legacy/top.js layout)
      const uni    = device.createBuffer({ size: 64, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
      const statsA = device.createBuffer({ size: 12, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
      const statsB = device.createBuffer({ size: 12, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
      const readA  = device.createBuffer({ size: 12, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });
      const readB  = device.createBuffer({ size: 12, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });
      const zeroU32 = new Uint32Array([0,0,0]);

      // Pack uniforms like top.js (f16 HSV ranges + ROI + flags)
      const uniformArrayBuffer = new ArrayBuffer(64);
      const uniformU16 = new Uint16Array(uniformArrayBuffer);
      const uniformF32 = new Float32Array(uniformArrayBuffer);
      const uniformU32 = new Uint32Array(uniformArrayBuffer);
      function writeUniform(buf, hsvA6, hsvB6, rect, flags){
        const u16=uniformU16, f32=uniformF32, u32=uniformU32;
        // hsvA (6 halfs) -> u16[0..2], u16[4..6]
        for(let i=0;i<3;i++) u16[i]=hsvA6[i];
        for(let i=0;i<3;i++) u16[4+i]=hsvA6[i+3];
        // hsvB (6 halfs) -> u16[8..10], u16[12..14]
        for(let i=0;i<3;i++) u16[8+i]=hsvB6[i];
        for(let i=0;i<3;i++) u16[12+i]=hsvB6[i+3];
        // rect min/max (4 f32) -> f32[8..11]
        f32[8]=rect.min[0]; f32[9]=rect.min[1];
        f32[10]=rect.max[0]; f32[11]=rect.max[1];
        // flags (u32) -> u32[12]
        u32[12]=flags;
        device.queue.writeBuffer(buf,0,uniformArrayBuffer);
      }
      const FLAG_PREVIEW = 1, FLAG_TEAM_A_ACTIVE = 2, FLAG_TEAM_B_ACTIVE = 4;

      // 4) Pipelines from shared shader.wgsl (compute: 'main', render: 'vs'/'fs')
      const SHADER_CODE = await fetch('shader.wgsl').then(r=>r.text());
      const sharedMod = device.createShaderModule({ code: SHADER_CODE });
      const computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: { module: sharedMod, entryPoint: 'main' }
      });
      const renderPipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex:   { module: sharedMod, entryPoint: 'vs' },
        fragment: { module: sharedMod, entryPoint: 'fs', targets: [{ format }] },
        primitive: { topology: 'triangle-list' },
      });

      // Helper to (re)create textures/bind groups from a VideoFrame's coded size
      async function ensureTextures(frame) {
        const w = frame.codedWidth, h = frame.codedHeight;
        if (frameTex1 && w === width && h === height) return;

        width = w; height = h;
        canvas.width = frame.displayWidth;
        canvas.height = frame.displayHeight;

        frameTex1?.destroy?.();
        maskTex1?.destroy?.();

        // camera frame (sampled/RT) + mask (storage/sampled/RT)
        frameTex1 = device.createTexture({
          size: { width, height },
          format: 'rgba8unorm',
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
        });
        maskTex1 = device.createTexture({
          size: { width, height },
          format: 'rgba8unorm',
          usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST
        });

        xGroups = Math.ceil(width / WG_X);
        yGroups = Math.ceil(height / WG_Y);

        // compute BG: {0:frameTex1,1:maskTex1,2:statsA,3:statsB,6:uni}
        bgTop = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: frameTex1.createView() },
            { binding: 1, resource: maskTex1.createView() },
            { binding: 2, resource: { buffer: statsA } },
            { binding: 3, resource: { buffer: statsB } },
            { binding: 6, resource: { buffer: uni } }
          ]
        });
        // render BG: {0:frameTex1,4:maskTex1,5:sampler}
        bgR = device.createBindGroup({
          layout: renderPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: frameTex1.createView() },
            { binding: 4, resource: maskTex1.createView() },
            { binding: 5, resource: blitSampler }
          ]
        });

        info.textContent = `Running ${width}Ã—${height}, shader.wgsl compute+render (VideoFrame).`;
      }

      // 5) Worker: iOS Safari exposes MediaStreamTrackProcessor only in a Dedicated Worker.
      //    We transfer the camera track to the worker; it posts VideoFrames back to main.
      const workerSrc = /* js */`
        self.onmessage = async (e) => {
          const { op } = e.data || {};
          if (op === 'init-track') {
            const { track } = e.data;
            if (!track) return;
            // Create MSTP in worker and stream frames to main
            const processor = new MediaStreamTrackProcessor({ track });
            const reader = processor.readable.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } else if (op === 'init-stream') {
            const { stream } = e.data;
            if (!stream) return;
            const reader = stream.getReader();
            for (;;) {
              const { value: frame, done } = await reader.read();
              if (done || !frame) break;
              self.postMessage(frame, [frame]); // transfer ownership
            }
          } // else ignore
        };
      `;
      const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: 'text/javascript' }));
      const videoWorker = new Worker(workerURL, { type: 'module' });
      URL.revokeObjectURL(workerURL);

      // Try to transfer the MediaStreamTrack to the worker first (iOS-friendly).
      // If this throws (e.g., Chrome Windows), fall back to sending a ReadableStream.
      try {
        videoWorker.postMessage({ op: 'init-track', track }, [track]);
      } catch (e) {
        const processor = new MediaStreamTrackProcessor({ track });
        videoWorker.postMessage({ op: 'init-stream', stream: processor.readable }, [processor.readable]);
      }

      // 6) Main-thread pump: CEITT â†’ compute(main) â†’ render(vs/fs)
      videoWorker.onmessage = async (ev) => {
        const frame = ev.data; // VideoFrame (transferred)
        if (!frame) return;
        if (busy) { frame.close(); return; }
        busy = true;
        try {
          await ensureTextures(frame);

          // Upload camera frame into frameTex1
          device.queue.copyExternalImageToTexture(
            { source: frame , flipY:true },
            { texture: frameTex1, colorSpace: 'srgb' },
            { width, height }
          );

          // reset stats and write uniforms (full-frame ROI; preview+both teams flags)
          device.queue.writeBuffer(statsA,0,zeroU32);
          device.queue.writeBuffer(statsB,0,zeroU32);
          writeUniform(
            uni,
            cfg.f16Ranges[cfg.teamA],
            cfg.f16Ranges[cfg.teamB],
            {min:[0,0], max:[width,height]},
            (FLAG_PREVIEW | FLAG_TEAM_A_ACTIVE | FLAG_TEAM_B_ACTIVE)
          );

          const enc = device.createCommandEncoder();
          {
            const pass = enc.beginComputePass();
            pass.setPipeline(computePipeline);
            pass.setBindGroup(0, bgTop);
            pass.dispatchWorkgroups(xGroups, yGroups);
            pass.end();
          }
          {
            const colorView = ctx.getCurrentTexture().createView();
            const pass = enc.beginRenderPass({
              colorAttachments: [{
                view: colorView,
                loadOp: 'clear',
                clearValue: { r: 0, g: 0, b: 0, a: 1 },
                storeOp: 'store'
              }]
            });
            pass.setPipeline(renderPipeline);
            pass.setBindGroup(0, bgR);
            pass.draw(3);
            pass.end();
          }
          // optional: copy stats out (not displayed here)
          enc.copyBufferToBuffer(statsA,0,readA,0,12);
          enc.copyBufferToBuffer(statsB,0,readB,0,12);

          device.queue.submit([enc.finish()]);
          await Promise.all([readA.mapAsync(GPUMapMode.READ), readB.mapAsync(GPUMapMode.READ)]);
          const [cntA] = new Uint32Array(readA.getMappedRange());
          readA.unmap();
          const [cntB] = new Uint32Array(readB.getMappedRange());
          readB.unmap();
          const a = cntA > cfg.topMinArea;
          const b = cntB > cfg.topMinArea;
          info.textContent = `${COLOR_EMOJI[cfg.teamA]}:${cntA} ${a?'âœ“':''} ${COLOR_EMOJI[cfg.teamB]}:${cntB} ${b?'âœ“':''}`;
        } finally {
          frame.close(); // always release
          busy = false;
        }
      };

    } catch (err) {
      info.textContent = (err && err.message) ? err.message : String(err);
      start.disabled = false;
      console.error(err);
    }
  });
</script>

</body>
</html>
